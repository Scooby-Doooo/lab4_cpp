# Звіт з Лабораторної роботи №4

---

### 1. Інформація про виконавця
**ПІБ:** Вівтоніченко Дмитро Олегович
**Група:** К-27

---

### 2. Умова задачі (Варіант 10)

Частоти операцій для варіанту 10:

| Операція | Поле 0 | Поле 1 | Поле 2 | String |
|----------|--------|--------|--------|--------|
| **Read** | 1%     | 1%     | 1%     | -      |
| **Write**| 40%    | 5%     | 5%     | -      |
| **String**| -     | -      | -      | 47%    |

---

### 3. Схема захисту даних

**Використано 3 окремих м'ютекси** (по одному на кожне поле).

**Обґрунтування:**
- Операції read/write блокують тільки м'ютекс відповідного поля, що дозволяє паралельне виконання операцій над різними полями
- Операція string блокує всі 3 м'ютекси одночасно через `std::lock()` для забезпечення консистентності даних та уникнення deadlock
- Така схема оптимальна для мого варінту, де write field 0 (40%) та string (47%) домінують у навантаженні
- Операції над різними полями можуть виконуватися паралельно, що теоретично має збільшувати пропускну здатність при багатопотоковому доступі
---

### 4. Результати виконання

Результати вимірювань для 100,000 операцій (час у мілісекундах):

| Файл | 1 потік | 2 потоки | 3 потоки |
|------|---------|----------|----------|
| **A (Варіант 10)** | 86.81   | 205.55   | 318.44   |
| **B (Рівні частоти)** | 28.52   | 69.28    | 128.94   |
| **C (Власні частоти)** | 20.00   | 65.26    | 80.51    |

**Примітка:** Файл C має частоти: write по 10%, read по 20%, string 10%.

---

### 5. Висновки

**Спостереження:** Час виконання збільшується зі зростанням кількості потоків для всіх типів файлів.

**Пояснення результатів:**

1. Файл A показує найгірші результати при багатопотоковості через високий відсоток операції string (47%), яка блокує всі м'ютекси одночасно. Це створює ситуацію, де всі потоки змушені чекати один одного.

2. Файл B демонструє середні результати, оскільки операції розподілені рівномірно (~14% кожна), що зменшує конкуренцію, але overhead від синхронізації все одно присутній.

3. Файл C показує найкращі результати завдяки мінімальній кількості string операцій (10%) та переважанню read операцій (60%), які менш конфліктні.

**Загальний висновок:** Результати відповідають очікуванням для даної архітектури синхронізації. Overhead від управління потоками та конкуренція за м'ютекси перевищують виграш від паралелізму, особливо коли домінують операції, що вимагають глобального блокування (string). Для реального прискорення потрібен більш складний розподіл роботи або інша стратегія синхронізації.

---

### 6. Виконано самостійно:
- Розробка класу `ThreadSafeData` з 3 м'ютексами та захопленням через `std::lock()`
- Реалізація генератора файлів `FileGenerator`.
- Створення модуля `Executor` для завантаження команд та вимірювання часу виконання з виключенням часу читання файлів
- Написання демо-коду з автоматичною генерацією тестових файлів для 1, 2 та 3 потоків
---
**Дата виконання:** 13 листопада 2025 р.
